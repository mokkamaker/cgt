{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.1;\r\ncontract DumbPool {\r\n    // Data structure per user\r\n    struct UserData {\r\n        uint    bitcoinPublicKey;\r\n        uint    numPendingShares;\r\n        uint    pendingSharesMerkle;\r\n        uint    numVerifiedUnpaidShares;\r\n        uint    lastVerifiedTimeStamp;\r\n        bool    verificationCompleted;\r\n    }\r\n    \r\n    struct PaymentData {\r\n        mapping(address=>uint) requestedAmounts;\r\n        uint                   totalSum;\r\n        bytes32[]              coinbaseOutputs;\r\n        mapping(address=>uint) userOutputIndexAndSum; // 0 = invalid\r\n                                                      // 128 bits index\r\n                                                      // 128 bits sum\r\n    }\r\n    \r\n    uint[] foundedBlocksTimestamps;\r\n    mapping(uint=>PaymentData) paymentPerFoundBlock;\r\n    mapping(address=>UserData) userData;\r\n    \r\n    uint blockDelayForPaymentRequest = 20;\r\n    uint nextAvailPaymentBlock = 0;\r\n\r\n    \r\n    function DumbPool() { \r\n    \tfoundedBlocksTimestamps.length = 2;\r\n    \tfoundedBlocksTimestamps[0] = 0;\r\n    \tfoundedBlocksTimestamps[1] = 5;\t\r\n    }\r\n\r\n    event DebugError( string msg );\r\n\r\n    function reportError( string msg ) internal constant returns(bool){\r\n        DebugError(msg);\r\n        return false;\r\n    }\r\n    \r\n    function register( uint _bitcoinPublicKey ) {\r\n        UserData data = userData[ msg.sender ];\r\n        data.verificationCompleted = true;\r\n        data.bitcoinPublicKey = _bitcoinPublicKey;\r\n    }\r\n    \r\n    function constructCoinbaseTx( uint blockNumber, uint amount ) returns(bool) { // TODO make internal\r\n        if( blockNumber < nextAvailPaymentBlock ) blockNumber = nextAvailPaymentBlock;\r\n        else nextAvailPaymentBlock = blockNumber;\r\n        PaymentData paymentData = paymentPerFoundBlock[blockNumber];\r\n        if( amount + paymentData.totalSum > 10000 ) {// TODO replace with real value\r\n            nextAvailPaymentBlock++;\r\n            paymentData = paymentPerFoundBlock[nextAvailPaymentBlock];\r\n        }\r\n        \r\n        uint userIndexAndSum = paymentData.userOutputIndexAndSum[msg.sender];\r\n        uint userIndex = userIndexAndSum / (2 ** 128);\r\n        uint userSum   = userIndexAndSum & (2**128 - 1);\r\n        if( userSum == 0 ) {\r\n            userIndex = paymentData.coinbaseOutputs.length;\r\n            paymentData.coinbaseOutputs.length += 2;\r\n        }\r\n        \r\n        userSum += amount;\r\n\r\n        // construct tx output\r\n        uint word0 = 0x00;\r\n\r\n        // 8 bytes amount - todo should be in satoshi\r\n        word0 = userSum & 0xFFFFFFFFFFFFFFFF;\r\n\r\n        /*        \r\n        uint index;\r\n        for( index = 0 ; index < 8 ; index++ ) {\r\n            paymentData.coinbaseOutputs.push(byte(actualPayment & 0xFF));\r\n            actualPayment = actualPayment / 256;\r\n        }*/\r\n\r\n        /*        \r\n        // size of script\r\n        paymentData.coinbaseOutputs.push(byte(0x19));\r\n        \r\n        // script\r\n        uint publicKeyHash = userData[ msg.sender ].bitcoinPublicKey;\r\n        paymentData.coinbaseOutputs.push(byte(0x76)); // OP_DUP\r\n        paymentData.coinbaseOutputs.push(byte(0xa9)); // OP_HASH160\r\n        paymentData.coinbaseOutputs.push(byte(0x13)); // Push 20 bytes as data\r\n        */\r\n        word0 = word0 | (0x1976a913) * (2 ** 64);\r\n        \r\n        /*\r\n        for( index = 0 ; index < 20 ; index++ ) {\r\n            paymentData.coinbaseOutputs.push(byte(publicKeyHash & 0xFF));\r\n            publicKeyHash = publicKeyHash / 256;\r\n        }*/\r\n        uint publicKeyHash = userData[ msg.sender ].bitcoinPublicKey;        \r\n        word0 = word0 | ( publicKeyHash & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) * (2 ** 96);\r\n        paymentData.coinbaseOutputs[userIndex] = bytes32(word0);\r\n\r\n        /*        \r\n        paymentData.coinbaseOutputs.push(byte(0x88)); // OP_EQUALVERIFY\r\n        paymentData.coinbaseOutputs.push(byte(0xac)); // OP_CHECKSIG\r\n        */\r\n\r\n        uint word1 = 0x88ac;\r\n        paymentData.coinbaseOutputs[userIndex + 1] = bytes32(word1);\r\n\r\n        paymentData.totalSum += amount;\r\n        paymentData.userOutputIndexAndSum[msg.sender] = userSum | (userIndex * 2**128);\r\n\r\n        reportError(\"constructCoinbaseTx ok\");\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n\r\n    \r\n    function submitShares( uint _sharesMerkle, uint _numShares ) {\r\n        UserData data = userData[ msg.sender ];\r\n        if( ! data.verificationCompleted ) throw;\r\n        data.numPendingShares = _numShares;\r\n        data.pendingSharesMerkle = _sharesMerkle;\r\n        data.verificationCompleted = false;\r\n    }\r\n        \r\n    \r\n    function hash( uint x, uint y ) internal constant returns(uint) {\r\n        // 16 bytes hash\r\n        return uint(sha3(x,y)) & ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n    \r\n    function nodeMinTimeStamp( uint node ) internal constant returns(uint) {\r\n        return node & 0xFFFFFFFF;\r\n    }\r\n\r\n    function nodeMaxTimeStamp( uint node ) internal constant returns(uint) {\r\n        return (node & 0xFFFFFFFF00000000) / 2**32;\r\n    }\r\n\r\n    function nodeHash( uint node ) internal constant returns(uint) {\r\n        return (node & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000) / 2 ** 64;\r\n    }\r\n\r\n    function blockHeaderTimeStamp( bytes blockHeader ) internal constant returns(uint) {\r\n        uint result = 0x00;\r\n        result = uint(blockHeader[71]) | (uint( blockHeader[70] ) * 2**8) | (uint( blockHeader[69] ) * 2**16) |\r\n                 (uint(blockHeader[68]) * 2**24);\r\n        return result;\r\n    }\r\n\r\n    function blockHeaderMerkle( bytes blockHeader ) internal constant returns(uint) {\r\n        uint result = 0x00;\r\n        for( uint index = 0 ; index < 32 ; index++ ) {\r\n            result += uint(blockHeader[36 + 32 - index - 1]) * (2**(index * 8));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    \r\n    function verifyShare( bytes coinBaseTxPrefix,\r\n                          uint[] merkleBranch,\r\n                          uint[] sibling,\r\n                          bytes blockHeader,\r\n                          uint  timestampIndex ) returns (bool) {\r\n        uint length = merkleBranch.length;                              \r\n        uint leaf = merkleBranch[ length - 1 ];\r\n        \r\n        if( leaf != uint( sha256(sha256(coinBaseTxPrefix,\r\n                                        paymentPerFoundBlock[timestampIndex].coinbaseOutputs)))) return reportError(\"merkle leaf does not fit coinbasetx\");\r\n                              \r\n        uint blockSha = uint(sha256(sha256(blockHeader)));\r\n        if( ( blockSha & 0x03 ) > 0 ) return false; // set trivial difficulty for testing\r\n        if( merkleBranch[ 0 ] != blockHeaderMerkle( blockHeader ) ) return reportError(\"merkle root doesn't fit block header\");\r\n        for( uint index = 0 ; index < length - 1 ; index++ ) {\r\n            // note that we only test branch zero\r\n            uint expected = uint(sha256(sha256(merkleBranch[index+1],sibling[index])));\r\n            if( merkleBranch[index] != expected ) return reportError(\"Merkle branch is wrong\");\r\n        }\r\n\r\n\treportError( \"Verification ok\" );        \r\n\r\n        return constructCoinbaseTx(foundedBlocksTimestamps.length + blockDelayForPaymentRequest, 100);\r\n    }\r\n\r\n    function verifySharesTreeSubmission( uint[] nodes,\r\n                                         uint[] sibling,\r\n                                         uint treeHeight,\r\n                                         uint blockSha3,\r\n                                         uint shareTimeStamp,\r\n                                         uint seed ) internal constant returns(bool) {\r\n        for( uint index = 0 ; index < treeHeight - 1; index++ ) {\r\n            // go from leaf upwards. Special treatment for root\r\n            uint node = nodes[index];\r\n            bool isALeftChild = ((seed & (2 ** index)) > 0);\r\n            uint childA = nodes[index + 1 ];\r\n            uint childB = sibling[ index ];\r\n            \r\n            uint min; uint max; uint hashResult;\r\n            if( isALeftChild ) {\r\n                min = nodeMinTimeStamp( childA );\r\n                max = nodeMaxTimeStamp( childB );\r\n                hashResult = hash( childA, childB );\r\n            } else {\r\n                min = nodeMinTimeStamp( childB );\r\n                max = nodeMaxTimeStamp( childA );\r\n                hashResult = hash( childB, childA );\r\n            }\r\n            \r\n            if( min != nodeMinTimeStamp( node ) ) return reportError(\"min does not fit node\");\r\n            if( max != nodeMaxTimeStamp( node ) ) return reportError(\"max does not fit node\");\r\n            if( hashResult != nodeHash( node ) ) return reportError(\"hash does not fit node\");\r\n            if( min >= max ) return reportError(\"min >= max\");\r\n        }\r\n        \r\n        uint leafNode = nodes[ treeHeight - 1 ];\r\n        // validate block header\r\n        if( nodeMinTimeStamp( leafNode ) != nodeMaxTimeStamp( leafNode ) ) return reportError(\"leaf time stamp min!=max\");\r\n        if( nodeHash( leafNode ) != hash(blockSha3,blockSha3) ) return reportError(\"leaf hash != blocksha3\");\r\n        if( shareTimeStamp != nodeMinTimeStamp( leafNode ) ) return reportError(\"leaf timestamp != min time stamp\");\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function verifyPendingShares( uint[] augmentedBranch,\r\n                                  uint[] augmentedSibils,\r\n                                  uint   seed,\r\n                                  uint[] blockMerkleBranch,\r\n                                  uint[] blockSibils,\r\n                                  bytes  blockHeader,\r\n                                  bytes  coinbaseTxPrefix,\r\n                                  uint   timestampIndex ) returns (bool){\r\n                                      \r\n        if( ! verifyShare( coinbaseTxPrefix,\r\n                           blockMerkleBranch,\r\n                           blockSibils,\r\n                           blockHeader,\r\n                           timestampIndex) ) return reportError(\"verifyShare failed\");\r\n                                      \r\n        UserData data = userData[ msg.sender ];\r\n        if( data.verificationCompleted ) return reportError(\"previous verification not completed\");\r\n        if( nodeMinTimeStamp(augmentedBranch[0]) <= data.lastVerifiedTimeStamp ) return reportError(\"nodeMinTimeStamp(augmentedBranch[0]) <= data.lastVerifiedTimeStamp\");\r\n        uint shareTimestamp = blockHeaderTimeStamp(blockHeader);\r\n        if( (2 ** (augmentedBranch.length-1)) != data.numPendingShares ) return reportError(\"2 **(branch length-1) != num pending shares\"); // we assume always full tree\r\n         // check merkle is the same\r\n        if( augmentedBranch[0] != data.pendingSharesMerkle ) return reportError(\"augRoot != pending merkle root\");\r\n\r\n        \r\n        if( foundedBlocksTimestamps[timestampIndex] > shareTimestamp ) return reportError(\"timestamp index too low\");\r\n        if( foundedBlocksTimestamps[timestampIndex + 1 ] < shareTimestamp ) {\r\n            if( foundedBlocksTimestamps.length > timestampIndex + 1 ) return reportError(\"timestamp index too high\");\r\n        }\r\n        \r\n        if( ! verifySharesTreeSubmission( augmentedBranch,\r\n                                          augmentedSibils,\r\n                                          augmentedBranch.length,\r\n                                          uint(sha3(blockHeader)),\r\n                                          shareTimestamp,\r\n                                          seed ) ) return reportError(\"verifySharesTreeSubmission failed\");\r\n\r\n        data.numVerifiedUnpaidShares = data.numPendingShares;\r\n        data.numPendingShares = 0;\r\n        data.lastVerifiedTimeStamp = shareTimestamp;\r\n        data.verificationCompleted = true;\r\n        reportError(\"Verification completed\");\r\n\r\n        return constructCoinbaseTx(foundedBlocksTimestamps.length + blockDelayForPaymentRequest, 100);\r\n    }\r\n\r\n    function compareBlockHeaderAndPrev( bytes prevHeader, bytes header ) constant internal returns(bool) {\r\n        uint prev = 0;\r\n        uint prevSha = uint(sha256(sha256(prevHeader)));\r\n        if( prevSha & 0x03 > 0 ) return reportError(\"compareBlockHeaderAndPrev: difficulty too low\"); // check dummy difficulty for debug\r\n        for( uint index = 4 ; index < 36 ; index++ ) {\r\n            prev = uint(header[index]) | (prev * 256);\r\n        }\r\n        \r\n        return ( prev == prevSha );\r\n    }\r\n\r\n\r\n    function submitFullBlock( bytes coinBaseTxPrefix,\r\n                              uint[] merkleBranch,\r\n                              uint[] sibling,\r\n                              bytes blockHeader,\r\n                              bytes blockHeader1,\r\n                              bytes blockHeader2,                              \r\n                              bytes blockHeader3,                              \r\n                              bytes blockHeader4,                              \r\n                              bytes blockHeader5,                              \r\n                              uint  timestampIndex ) returns (bool) {\r\n        if( ! verifyShare( coinBaseTxPrefix, merkleBranch, sibling, blockHeader, timestampIndex ) ) {\r\n            return reportError(\"verifyShare failed\");            \r\n        }\r\n        if( ! compareBlockHeaderAndPrev( blockHeader, blockHeader1 ) ) {\r\n            return reportError(\"compareBlockHeaderAndPrev( blockHeader, blockHeader1 ) failed\");\r\n        }    \r\n        if( ! compareBlockHeaderAndPrev( blockHeader1, blockHeader2 ) ) {\r\n            return reportError(\"compareBlockHeaderAndPrev( blockHeader1, blockHeader2 ) failed\");\r\n        }    \r\n        if( ! compareBlockHeaderAndPrev( blockHeader2, blockHeader3 ) ) {\r\n            return reportError(\"compareBlockHeaderAndPrev( blockHeader2, blockHeader3 ) failed\");\r\n        }    \r\n        if( ! compareBlockHeaderAndPrev( blockHeader3, blockHeader4 ) ) {\r\n            return reportError(\"compareBlockHeaderAndPrev( blockHeader3, blockHeader4 ) failed\");\r\n        }    \r\n        if( ! compareBlockHeaderAndPrev( blockHeader4, blockHeader5 ) ) {\r\n            return reportError(\"compareBlockHeaderAndPrev( blockHeader4, blockHeader5 ) failed\");\r\n        }    \r\n        \r\n        if( uint( sha256(sha256(blockHeader5))) & 0x03 > 0 ) return reportError(\"block5 diff too small\"); // dummy difficulty for debug\r\n        \r\n        \r\n        // submission is valid\r\n        UserData data = userData[ msg.sender ];\r\n        data.numVerifiedUnpaidShares += 10000;\r\n        foundedBlocksTimestamps.push(blockHeaderTimeStamp(blockHeader));\r\n\r\n        reportError(\"ok\");\r\n        return true;\r\n    }\r\n\r\n    event Log1( string func, uint x, uint result );\r\n    event Log2( string func, bytes x, uint result );    \r\n    event Log3( string func, bytes x, bytes y, bytes z, uint result );    \r\n    function debug_hash3Int( uint x ) {\r\n        Log1( \"debug_hash3Int\", x, uint(sha3(x)) );\r\n    }\r\n    \r\n    function debug_hash3Byte( bytes x ) {\r\n        Log2( \"debug_hash3Byte\", x, uint(sha3(x)) );        \r\n    }\r\n\r\n    function debug_hash256Double( bytes x ) {\r\n        Log2( \"debug_hash256Double\", x, uint(sha256(sha256(x))) );        \r\n    }\r\n\r\n    function debug_hash256Double_concat( bytes x, bytes y, bytes z ) {\r\n        Log3( \"debug_hash256Double\", x, y,z, uint(sha256(sha256(x,y,z))) );        \r\n    }\r\n \r\n    function debug_verifyShare( bytes coinBaseTxMiddle,\r\n                          uint[] merkleBranch,\r\n                          uint[] sibling,\r\n                          bytes blockHeader,\r\n                          uint  timestampIndex,\r\n                          uint  steps ) constant returns (uint) {\r\n        uint length = merkleBranch.length;                              \r\n        uint leaf = merkleBranch[ length - 1 ];\r\n        if( steps < 1 ) return 0;\r\n        uint sha = uint( sha256(sha256(coinBaseTxMiddle,\r\n                                       paymentPerFoundBlock[timestampIndex].coinbaseOutputs)));\r\n        if( leaf != sha) return sha;\r\n        if( steps < 2 ) return 2;                      \r\n        uint blockSha = uint(sha256(sha256(blockHeader)));\r\n        if( steps < 3 ) return 3;\r\n        if( ( blockSha & 0x03 ) > 0 ) return 4; // set trivial difficulty for testing\r\n        if( steps < 4 ) return 5;\r\n        if( steps < 5 ) return 6;\r\n        if( merkleBranch[ 0 ] != blockHeaderMerkle( blockHeader ) ) return 7;\r\n        if( steps < 6 ) return 8;\r\n        for( uint index = 0 ; index < length - 1 ; index++ ) {\r\n            // note that we only test branch zero\r\n            uint expected = uint(sha256(sha256(merkleBranch[index+1],sibling[index])));\r\n            if( merkleBranch[index] != expected ) return (9 + index);\r\n        }\r\n        \r\n        return 10000;\r\n    } \r\n    \r\n    function debug_verifySharesTreeSubmission( uint[] nodes,\r\n                                         uint[] sibling,\r\n                                         uint treeHeight,\r\n                                         uint blockSha3,\r\n                                         uint shareTimeStamp,\r\n                                         uint seed ) constant returns(string) {\r\n        for( uint index = 0 ; index < treeHeight - 1; index++ ) {\r\n            // go from leaf upwards. Special treatment for root\r\n            uint node = nodes[index];\r\n            bool isALeftChild = ((seed & (2 ** index)) > 0);\r\n            uint childA = nodes[index + 1 ];\r\n            uint childB = sibling[ index ];\r\n            \r\n            uint min; uint max; uint hashResult;\r\n            if( isALeftChild ) {\r\n                min = nodeMinTimeStamp( childA );\r\n                max = nodeMaxTimeStamp( childB );\r\n                hashResult = hash( childA, childB );\r\n            } else {\r\n                min = nodeMinTimeStamp( childB );\r\n                max = nodeMaxTimeStamp( childA );\r\n                hashResult = hash( childB, childA );\r\n            }\r\n            \r\n            if( min != nodeMinTimeStamp( node ) ) return \"min does not fit node\";\r\n            if( max != nodeMaxTimeStamp( node ) ) return \"max does not fit node\";\r\n            if( hashResult != nodeHash( node ) ) return \"hash does not fit node\";\r\n            if( min >= max ) return \"min >= max\";\r\n        }\r\n        \r\n        uint leafNode = nodes[ treeHeight - 1 ];\r\n        // validate block header\r\n        if( nodeMinTimeStamp( leafNode ) != nodeMaxTimeStamp( leafNode ) ) return \"leaf time stamp min!=max\";\r\n        if( nodeHash( leafNode ) != hash(blockSha3,blockSha3) ) return \"leaf hash != blocksha3\";\r\n        if( shareTimeStamp != nodeMinTimeStamp( leafNode ) ) return \"leaf timestamp != min time stamp\";\r\n        \r\n        return \"ok\";\r\n    }\r\n    \r\n    function debug_blockHeaderMerkle( bytes blockHeader ) constant returns(uint) {\r\n        uint result = 0x00;\r\n        for( uint index = 0 ; index < 32 ; index++ ) {\r\n            result += uint(blockHeader[36 + 32 - index - 1]) * (2**(index * 8));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    function debug_resetuser( ) {\r\n        UserData data = userData[ msg.sender ];\r\n        data.lastVerifiedTimeStamp = 0;\r\n        data.verificationCompleted = true;\r\n    }\r\n    \r\n    function debug_multiplehash( uint x, uint y ) constant returns(uint) {\r\n        return uint(sha3(x,y));\r\n    }\r\n    \r\n    function debug_getCoinbaseTxOutputLen(uint blockNumber) constant returns(uint) {\r\n        return paymentPerFoundBlock[blockNumber].coinbaseOutputs.length;        \r\n    }\r\n    \r\n    function debug_resizeRealPrefix(uint size, uint blockNumber) {\r\n        paymentPerFoundBlock[blockNumber].coinbaseOutputs.length = size;\r\n    }\r\n \r\n    function debug_coinbaseTxSha( bytes prefix, uint blockNumber ) constant returns(uint){\r\n        uint sha = uint( sha256(sha256(prefix,\r\n                                       paymentPerFoundBlock[blockNumber].coinbaseOutputs)));\r\n        return sha;\r\n    }   \r\n    \r\n    function debug_extendCoinbaseTxOutput( uint blockNumber, uint length ) {\r\n        bytes32 const = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;       \r\n        for( uint index = 0 ; index < (length / 32) ; index++ ) {\r\n            paymentPerFoundBlock[blockNumber].coinbaseOutputs.push(const);\r\n        }\r\n    }    \r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"debug_coinbaseTxSha\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"coinBaseTxMiddle\",\"type\":\"bytes\"},{\"name\":\"merkleBranch\",\"type\":\"uint256[]\"},{\"name\":\"sibling\",\"type\":\"uint256[]\"},{\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"name\":\"timestampIndex\",\"type\":\"uint256\"},{\"name\":\"steps\",\"type\":\"uint256\"}],\"name\":\"debug_verifyShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"coinBaseTxPrefix\",\"type\":\"bytes\"},{\"name\":\"merkleBranch\",\"type\":\"uint256[]\"},{\"name\":\"sibling\",\"type\":\"uint256[]\"},{\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"name\":\"blockHeader1\",\"type\":\"bytes\"},{\"name\":\"blockHeader2\",\"type\":\"bytes\"},{\"name\":\"blockHeader3\",\"type\":\"bytes\"},{\"name\":\"blockHeader4\",\"type\":\"bytes\"},{\"name\":\"blockHeader5\",\"type\":\"bytes\"},{\"name\":\"timestampIndex\",\"type\":\"uint256\"}],\"name\":\"submitFullBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"debug_extendCoinbaseTxOutput\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"debug_resetuser\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sharesMerkle\",\"type\":\"uint256\"},{\"name\":\"_numShares\",\"type\":\"uint256\"}],\"name\":\"submitShares\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"debug_hash3Int\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"debug_multiplehash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes\"}],\"name\":\"debug_hash256Double\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"constructCoinbaseTx\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"coinBaseTxPrefix\",\"type\":\"bytes\"},{\"name\":\"merkleBranch\",\"type\":\"uint256[]\"},{\"name\":\"sibling\",\"type\":\"uint256[]\"},{\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"name\":\"timestampIndex\",\"type\":\"uint256\"}],\"name\":\"verifyShare\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes\"}],\"name\":\"debug_hash3Byte\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockHeader\",\"type\":\"bytes\"}],\"name\":\"debug_blockHeaderMerkle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"debug_getCoinbaseTxOutputLen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes\"},{\"name\":\"y\",\"type\":\"bytes\"},{\"name\":\"z\",\"type\":\"bytes\"}],\"name\":\"debug_hash256Double_concat\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"augmentedBranch\",\"type\":\"uint256[]\"},{\"name\":\"augmentedSibils\",\"type\":\"uint256[]\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"blockMerkleBranch\",\"type\":\"uint256[]\"},{\"name\":\"blockSibils\",\"type\":\"uint256[]\"},{\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"name\":\"coinbaseTxPrefix\",\"type\":\"bytes\"},{\"name\":\"timestampIndex\",\"type\":\"uint256\"}],\"name\":\"verifyPendingShares\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nodes\",\"type\":\"uint256[]\"},{\"name\":\"sibling\",\"type\":\"uint256[]\"},{\"name\":\"treeHeight\",\"type\":\"uint256\"},{\"name\":\"blockSha3\",\"type\":\"uint256\"},{\"name\":\"shareTimeStamp\",\"type\":\"uint256\"},{\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"debug_verifySharesTreeSubmission\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"size\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"debug_resizeRealPrefix\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bitcoinPublicKey\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"DebugError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"func\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"x\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"Log1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"func\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"x\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"Log2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"func\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"x\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"y\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"z\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"Log3\",\"type\":\"event\"}]", "ContractName": "DumbPool", "CompilerVersion": "v0.4.2-nightly.2016.9.17+commit.212e0160", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}