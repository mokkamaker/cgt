{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.2;\r\n\r\ncontract IDCaseD{\r\n    address public owner;\r\n    mapping (address => int) public challenge;\r\n    mapping (address => int) public solution;\r\n    int public publicRSAModule;\r\n    int public publicRSAPower;\r\n     \r\n    function IDCaseD(int _RSAModule, int _RSAPower){\r\n        publicRSAModule = _RSAModule;\r\n        publicRSAPower = _RSAPower;\r\n        owner = msg.sender;\r\n    }\r\n \r\n    modifier onlyBy(address authorized){\r\n       if (msg.sender == authorized){\r\n           _;\r\n       }\r\n       else{\r\n           throw;\r\n       }\r\n    }\r\n    function sendChallenge(int chall) public {\r\n       challenge[msg.sender] = chall;\r\n    }\r\n     \r\n    function resolveChallenge(address challenger, int sol) onlyBy(owner){\r\n       solution[challenger] = sol;\r\n    }\r\n}\r\n\r\ncontract RSALib{\r\n    \r\n    modifier onlyBy(address authorized){\r\n        if (msg.sender == authorized){\r\n            _;\r\n        }\r\n        else{\r\n            throw;\r\n        }\r\n    }\r\n    function mod(int a, int n) returns (int){\r\n       return a - n*(a/n);\r\n    }\r\n     \r\n    function discretePower(int m, int d, int n) returns (int){\r\n       int refM = m;\r\n       int refD = d-1;\r\n       while (refD != 0){\r\n           if(mod(d,2) == 0){\r\n               refM = mod(refM*refM,n);\r\n               refD /= 2;\r\n           }\r\n           else{\r\n               refM = mod(refM*m,n);\r\n               refD -- ;\r\n           }\r\n        }\r\n        return refM;\r\n    }\r\n \r\n    function bezout(int a, int b)returns(int, int,int){\r\n       int rA=a;\r\n       int rB=b;\r\n       int uA = 1;\r\n       int vA = 0;\r\n       int uB = 0;\r\n       int vB = 1;\r\n       /*if (a >= b){\r\n           rA = a;\r\n           rB = b;\r\n       }\r\n       else{\r\n           rA = b;\r\n           rB = a;\r\n       }*/\r\n       while (rB != 0){\r\n           int q = rA/rB;\r\n           (rA, uA, vA, rB, uB, vB) = (rB, uB, vB, rA - q *rB, uA - q*uB, vA - q*vB);\r\n       }\r\n       return (rA,uA,vA);\r\n    }\r\n}\r\n\r\ncontract LocalA is RSALib{\r\n    int p;\r\n    int q;\r\n    int  public d;\r\n    int e;\r\n    IDCaseD public myIDContract;\r\n    \r\n    function LocalA(int _p, int _q){\r\n        p = _p;\r\n        q = _q;\r\n        generateD();\r\n        myIDContract = new IDCaseD(p*q, d);\r\n    }\r\n    \r\n    function setIDAddress(address _iDContract) public{\r\n        myIDContract = IDCaseD(_iDContract);\r\n    }\r\n    \r\n    function getE() public returns (int){\r\n        return e;\r\n    }\r\n    \r\n    function generateD()returns(int){\r\n        int phi = (p-1)*(q-1);\r\n        int ref = phi;\r\n        bool generated;\r\n        while(!generated){\r\n            d = mod(int(sha3(ref)), p*q);\r\n            int a;\r\n            int b;\r\n            int c;\r\n            (a,b,c) = bezout(d,phi);\r\n            if(a == 1 && b>0){\r\n                e = b;\r\n                generated = true;\r\n            }\r\n            else{\r\n                ref = d;\r\n            }\r\n        }\r\n        return e;\r\n    }\r\n    \r\n    function resolveChallengeAt(address user){\r\n        int cryptedMessage = myIDContract.challenge(user);\r\n        int decrypt = discretePower(cryptedMessage, e,p*q);\r\n        myIDContract.resolveChallenge(user, decrypt);\r\n    }\r\n}\r\n\r\ncontract LocalB is RSALib{\r\n    int message;\r\nbool succeed;\r\nbool fail;\r\n    \r\n    function LocalB(int _message){\r\n        message = _message;\r\n    }\r\n    \r\n    function sendChallengeTo(address _iDContract){\r\n        IDCaseD iDContract = IDCaseD(_iDContract);\r\n        iDContract.sendChallenge(discretePower(message, iDContract.publicRSAPower(), iDContract.publicRSAModule()));\r\n    }\r\n    \r\n    function checkSol(address _iDContract)returns(bool){\r\n        IDCaseD iDContract = IDCaseD(_iDContract);\r\n        if (message == iDContract.solution(this)){\r\n            succeed =  true;\r\n        }\r\n        else{\r\n            fail = true;\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"int256\"},{\"name\":\"n\",\"type\":\"int256\"}],\"name\":\"mod\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"resolveChallengeAt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_iDContract\",\"type\":\"address\"}],\"name\":\"setIDAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"int256\"},{\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"bezout\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"generateD\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"d\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myIDContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getE\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"m\",\"type\":\"int256\"},{\"name\":\"d\",\"type\":\"int256\"},{\"name\":\"n\",\"type\":\"int256\"}],\"name\":\"discretePower\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_p\",\"type\":\"int256\"},{\"name\":\"_q\",\"type\":\"int256\"}],\"type\":\"constructor\"}]", "ContractName": "LocalA", "CompilerVersion": "v0.4.2+commit.af6afb04", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000001d0000000000000000000000000000000000000000000000000000000000000025", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}