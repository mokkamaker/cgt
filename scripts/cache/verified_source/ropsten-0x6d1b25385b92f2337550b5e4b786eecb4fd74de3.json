{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.6;\r\n\r\ncontract RES { \r\n\r\n    /* Public variables of the token */\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    \r\n    uint public totalSupply;\r\n    \r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    \r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n\r\n    /* Bought or sold */\r\n\r\n    event Bought(address from, uint amount);\r\n    event Sold(address from, uint amount);\r\n\r\n    /* Initializes contract with name, symbol and decimals */\r\n\r\n    function RES() {\r\n        name = \"RES\";     \r\n        symbol = \"RES\";\r\n        decimals = 16;\r\n    }\r\n\r\n    function buy() public payable {\r\n      balanceOf[msg.sender] = msg.value;\r\n      totalSupply += msg.value;\r\n      Bought(msg.sender, msg.value);\r\n    }  \r\n\r\n}\r\n\r\ncontract SwarmRedistribution is RES {\r\n        \r\n    struct dividendPathway {\r\n      address from;\r\n      uint amount;\r\n      uint timeStamp;\r\n    }\r\n\r\n    mapping(address => dividendPathway[]) public dividendPathways;\r\n    \r\n    mapping(address => bool) public isHuman;\r\n\r\n    uint taxRate;\r\n    uint exchangeRate;\r\n\r\n    struct Node {\r\n      address node;\r\n      address parent;\r\n      uint index;\r\n    }\r\n    \r\n    /* Generate a swarm tree */\r\n    Node[] public swarmTree;\r\n    \r\n    uint humanCount;\r\n\r\n    event Swarm(address indexed leaf, address indexed node, uint256 share);\r\n\r\n    function SwarmRedistribution() {\r\n      \r\n    /* Tax-rate in parts per thousand */\r\n    taxRate = 20;\r\n    exchangeRate = 60;\r\n    }\r\n\r\n    \r\n    function setHuman(bool _isHuman) {\r\n        isHuman[msg.sender] = _isHuman;\r\n    }\r\n    \r\n    function sell(uint256 _value) public {\r\n      if(balanceOf[msg.sender] < _value) throw;\r\n      uint256 exchangeTax = _value * exchangeRate / 1000;\r\n      balanceOf[msg.sender] -= _value;\r\n\r\n        if(swarmRedistribution(msg.sender, exchangeTax) == true) {\r\n          if (!msg.sender.send(_value - exchangeTax))\r\n            throw;\r\n          totalSupply -= (_value - exchangeTax);\r\n          Sold(msg.sender, _value - exchangeTax);\r\n\r\n        }\r\n        else {\r\n          /* Return tax */\r\n          if (!msg.sender.send(_value))\r\n            throw;\r\n          totalSupply -= _value;\r\n          Sold(msg.sender, _value);\r\n\r\n          \r\n        }\r\n    }  \r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        /* reject transaction to self to prevent dividend pathway loops*/\r\n        if(_to == msg.sender) throw;\r\n        \r\n        /* if the sender doenst have enough balance then stop */\r\n        if (balanceOf[msg.sender] < _value) throw;\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\n        \r\n        /* Calculate tax */\r\n        uint256 taxCollected = _value * taxRate / 1000;\r\n        uint256 sentAmount;\r\n\r\n        /* Create the dividend pathway */\r\n        dividendPathways[_to].push(dividendPathway({\r\n                                        from: msg.sender, \r\n                                        amount:  _value,\r\n                                        timeStamp: now\r\n                                      }));\r\n        \r\n        if(swarmRedistribution(_to, taxCollected) == true) {\r\n          sentAmount = _value;\r\n        }\r\n        else {\r\n          /* Return tax */\r\n          sentAmount = _value - taxCollected;\r\n        }\r\n        \r\n          /* Add and subtract new balances */\r\n\r\n          balanceOf[msg.sender] -= sentAmount;\r\n          balanceOf[_to] += _value - taxCollected;\r\n        \r\n\r\n        /* Notifiy anyone listening that this transfer took place */\r\n        Transfer(msg.sender, _to, sentAmount);\r\n    }\r\n\r\n    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {\r\n           iterateThroughSwarm(_to, now);\r\n           if(swarmTree.length != 0) {\r\n           return doSwarm(_to, _taxCollected);\r\n           }\r\n           else return false;\r\n      }\r\n\r\n    function iterateThroughSwarm(address _node, uint _timeStamp) internal {\r\n      if(dividendPathways[_node].length != 0) {\r\n        for(uint i = 0; i < dividendPathways[_node].length; i++) {\r\n          uint timeStamp = dividendPathways[_node][i].timeStamp;\r\n          if(timeStamp <= _timeStamp) {\r\n            \r\n            bool human = isHuman[dividendPathways[_node][i].from];\r\n\r\n            if(human) humanCount++;\r\n            \r\n            Node memory node = Node({\r\n                        node: dividendPathways[_node][i].from, \r\n                        parent: _node,\r\n                        index: i\r\n                      });\r\n                      \r\n              swarmTree.push(node);\r\n              iterateThroughSwarm(node.node, timeStamp);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {\r\n      \r\n      /* If no humans in the swarm tree, then return the tax to msg.sender */\r\n      bool noHumans = false;\r\n      if(humanCount == 0) noHumans = true;\r\n      \r\n      uint256 share;\r\n      if(!noHumans) share = _taxCollected / humanCount;\r\n      else share = 0;\r\n    \r\n      for(uint i = 0; i < swarmTree.length; i++) {\r\n        \r\n        address node = swarmTree[i].node;\r\n        address parent = swarmTree[i].parent;\r\n        uint index = swarmTree[i].index;\r\n        \r\n        bool human = isHuman[node];\r\n\r\n        if(human) balanceOf[swarmTree[i].node] += share;\r\n          \r\n        if(dividendPathways[parent][index].amount - _taxCollected > 0) {\r\n          dividendPathways[parent][index].amount -= _taxCollected; \r\n        }\r\n        else removeDividendPathway(parent, index);\r\n        \r\n        /* Notifiy anyone listening that this swarm took place */\r\n        if(human) Swarm(_leaf, swarmTree[i].node, share);\r\n      }\r\n      delete swarmTree;\r\n      delete humanCount;\r\n\r\n      if(noHumans) return false;\r\n      return true;\r\n    }\r\n    \r\n    function removeDividendPathway(address node, uint index) internal {\r\n                delete dividendPathways[node][index];\r\n                for (uint i = index; i < dividendPathways[node].length - 1; i++) {\r\n                        dividendPathways[node][i] = dividendPathways[node][i + 1];\r\n                }\r\n                dividendPathways[node].length--;\r\n        }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swarmTree\",\"outputs\":[{\"name\":\"node\",\"type\":\"address\"},{\"name\":\"parent\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividendPathways\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isHuman\",\"type\":\"bool\"}],\"name\":\"setHuman\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isHuman\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"leaf\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"Swarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"}]", "ContractName": "SwarmRedistribution", "CompilerVersion": "v0.4.6+commit.2dabbdf0", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}