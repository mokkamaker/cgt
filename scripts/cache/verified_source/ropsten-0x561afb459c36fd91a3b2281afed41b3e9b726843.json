{"status": "1", "message": "OK", "result": [{"SourceCode": "contract Ethash {\r\n    function Ethash() {}\r\n    \r\n    uint merkleRoot = 0xcddd312dd2c15f394a49b417cd01bd2cabe7b863cbe3b65bfa22e4012da15bb4;\r\n    \r\n    function setMerkleRoot(uint root) {\r\n        merkleRoot = root;\r\n    }\r\n    \r\n    function sha3_512(bytes32 header, bytes8 nonceLe ) constant returns (uint[16]) {\r\n        return [uint(0),1,2,3,4,5,6,7,8,9,10,11,12,13,14,16];\r\n    }\r\n    \r\n    function fnv( uint v1, uint v2 ) constant returns(uint) {\r\n        return ((v1*0x01000193) ^ v2) & 0xFFFFFFFF;\r\n    }\r\n\r\n    function computeCacheRoot( uint index,\r\n                               uint[] dataSetLookup,\r\n                               uint[] witness,\r\n                               uint witnessIndex ) constant returns(uint) {\r\n        uint leaf = uint( sha3(dataSetLookup[4*witnessIndex],\r\n                               dataSetLookup[4*witnessIndex + 1],\r\n                               dataSetLookup[4*witnessIndex + 2],\r\n                               dataSetLookup[4*witnessIndex + 3]) );\r\n                   \r\n        uint[4] memory offsets = [ uint(2**0), 2**64, 2**128, 2**192];\r\n        \r\n        uint left;\r\n        uint right;\r\n                         \r\n        // witness[] stores 5 uint per cache element, each uint is 4 nodes\r\n        for( uint depth = 0 ; depth < 20 ; depth++ ) {\r\n            leaf = leaf & 0xFFFFFFFFFFFFFFFF;\r\n            // use offsets array to avoid expensive exp\r\n            uint node  = (witness[5*witnessIndex + depth/4] / offsets[depth%4])&0xFFFFFFFFFFFFFFFF;\r\n            if( index & 0x1 > 0 ) {\r\n                left = leaf;\r\n                right = node;\r\n            }\r\n            else {\r\n                left = node;\r\n                right = leaf;\r\n            }\r\n            \r\n            leaf = uint(sha3(left,right));\r\n            index = index / 2;\r\n        }\r\n        \r\n        \r\n        return leaf;\r\n    }\r\n    \r\n    function computeSha3( uint[16] s, uint32[4] cmix ) constant returns(uint) {\r\n        uint s0 = s[0] + s[1] * (2**32) + s[2] * (2**64) + s[3] * (2**96) +\r\n                  (s[4] + s[5] * (2**32) + s[6] * (2**64) + s[7] * (2**96))*(2**128);\r\n\r\n        uint s1 = s[8] + s[9] * (2**32) + s[10] * (2**64) + s[11] * (2**96) +\r\n                  (s[12] + s[13] * (2**32) + s[14] * (2**64) + s[15] * (2**96))*(2**128);\r\n                  \r\n        \r\n        return uint( sha3(s0,s1,\r\n                          bytes4(cmix[0]),bytes4(cmix[1]),bytes4(cmix[2]),bytes4(cmix[3])) );\r\n    }\r\n \r\n    event Log( string msg, uint i, uint p );\r\n    \r\n    function hashimoto( bytes32 header,\r\n                        bytes8 nonceLe,\r\n                        uint fullSize,\r\n                        uint[] dataSetLookup,\r\n                        uint[] witnessForLookup ) constant returns(uint) {\r\n    \r\n        uint[16] memory s;\r\n        uint[32] memory mix;\r\n        uint32[4] memory cmix;        \r\n        uint i;\r\n        uint j;\r\n        \r\n        s = sha3_512(header,nonceLe);\r\n        for( i = 0 ; i < 16 ; i++ ) {\r\n            mix[i] = s[i];\r\n            mix[i+16] = s[i];\r\n        }\r\n\r\n        for( i = 0 ; i < 64 ; i++ ) {\r\n            uint p = fnv( i ^ s[0], mix[i % 32]) % (fullSize / 128) * 2;\r\n            if( computeCacheRoot(p,dataSetLookup,witnessForLookup,i) != merkleRoot ) {\r\n                // PoW failed\r\n                Log(\"computeCacheRoot failed\", i, p);\r\n                return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            }\r\n            for( j = 0 ; j < 8 ; j++ ) {\r\n                mix[j] = fnv(mix[j], dataSetLookup[4*i] & 0xFFFFFFFF );\r\n                mix[j+8] = fnv(mix[j+8], dataSetLookup[4*i + 1] & 0xFFFFFFFF );\r\n                mix[j+16] = fnv(mix[j+16], dataSetLookup[4*i + 2] & 0xFFFFFFFF );                \r\n                mix[j+24] = fnv(mix[j+24], dataSetLookup[4*i + 3] & 0xFFFFFFFF );\r\n                \r\n                dataSetLookup[4*i    ] = dataSetLookup[4*i    ]/(2**32);\r\n                dataSetLookup[4*i + 1] = dataSetLookup[4*i + 1]/(2**32);\r\n                dataSetLookup[4*i + 2] = dataSetLookup[4*i + 2]/(2**32);\r\n                dataSetLookup[4*i + 3] = dataSetLookup[4*i + 3]/(2**32);\r\n            }\r\n        }\r\n        \r\n        for( i = 0 ; i < 16 ; i += 4) {\r\n            cmix[i/4] = uint32(fnv(fnv(fnv(mix[i], mix[i+1]), mix[i+2]), mix[i+3]));\r\n        }\r\n        \r\n\r\n        Log(\"Ok\",0,0);\r\n        return computeSha3(s,cmix);  \r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"dataSetLookup\",\"type\":\"uint256[]\"},{\"name\":\"witness\",\"type\":\"uint256[]\"},{\"name\":\"witnessIndex\",\"type\":\"uint256\"}],\"name\":\"computeCacheRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes32\"},{\"name\":\"nonceLe\",\"type\":\"bytes8\"},{\"name\":\"fullSize\",\"type\":\"uint256\"},{\"name\":\"dataSetLookup\",\"type\":\"uint256[]\"},{\"name\":\"witnessForLookup\",\"type\":\"uint256[]\"}],\"name\":\"hashimoto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"v1\",\"type\":\"uint256\"},{\"name\":\"v2\",\"type\":\"uint256\"}],\"name\":\"fnv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s\",\"type\":\"uint256[16]\"},{\"name\":\"cmix\",\"type\":\"uint32[4]\"}],\"name\":\"computeSha3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes32\"},{\"name\":\"nonceLe\",\"type\":\"bytes8\"}],\"name\":\"sha3_512\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[16]\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"i\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"}]", "ContractName": "Ethash", "CompilerVersion": "v0.4.2-nightly.2016.9.17+commit.212e0160", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}