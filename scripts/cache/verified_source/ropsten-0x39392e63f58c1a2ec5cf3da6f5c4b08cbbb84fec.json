{"status": "1", "message": "OK", "result": [{"SourceCode": "contract Looper { function maximumNumberOfLoops(uint _costSansLoops, uint _loopCost) returns (uint loopLimit) {} } \r\n\r\ncontract DepositGovernance {\r\n\r\n    address registrationDeposits;\r\n    address proofOfIndividuality;\r\n    Looper public looper;\r\n    \r\n    mapping(address => uint256) public registrationVote;\r\n    mapping(address => uint256) public votes;\r\n    \r\n    struct proposeNewDeposit {\r\n        uint256 depositSize;\r\n        uint256 votesInFavour; // in ether\r\n        uint256 votesAgainst;  // in ether\r\n    }\r\n    \r\n    proposeNewDeposit[] public proposals;\r\n    \r\n    mapping(uint => bool) isProposed;\r\n    \r\n    bool roundFinished;\r\n    \r\n    function DepositGovernance(uint _depositSize, address _poiContract, address _looperContract){\r\n        uint currentDepositSize = _depositSize;\r\n        proofOfIndividuality = _poiContract;\r\n        looper = Looper(_looperContract);\r\n        \r\n        proposals.push(proposeNewDeposit({\r\n                 depositSize: currentDepositSize,\r\n                 votesInFavour: 0,\r\n                 votesAgainst: 0\r\n             }));\r\n    }\r\n    \r\n    function setRegistrationDepositsContract(address _registrationDeposits) {\r\n        if(msg.sender != proofOfIndividuality) throw;\r\n        registrationDeposits = _registrationDeposits;\r\n    }\r\n    \r\n    /* \r\n        The registrant automatically uses their anti-spam deposits to vote for the \r\n        current depositSize. They can move their auto-vote to vote for other proposals \r\n        if they wish, by using voteOnProposal() \r\n    */\r\n    \r\n    function doRegistrationVote(address _registrant, uint _amount) external {\r\n        if(msg.sender != registrationDeposits) throw;\r\n        registrationVote[_registrant] += _amount;\r\n        proposals[0].votesInFavour += _amount;\r\n    }\r\n    \r\n\r\n    function newProposal(uint256 _depositSize) payable public {\r\n        \r\n        if(isProposed[_depositSize] == true) throw;\r\n    \r\n        if(_depositSize > msg.value + registrationVote[msg.sender]) throw;\r\n        \r\n        proposals.push(proposeNewDeposit({\r\n            depositSize: _depositSize,\r\n            votesInFavour: _depositSize,\r\n            votesAgainst: 0\r\n        }));\r\n        \r\n        registrationVote[msg.sender] -= (_depositSize - msg.value);\r\n        proposals[0].votesInFavour -= (_depositSize - msg.value);\r\n        votes[msg.sender] += msg.value;\r\n        \r\n        isProposed[_depositSize] = true;\r\n    }\r\n    \r\n    \r\n    \r\n    function voteOnProposal(uint proposalIndex, bool opinion, uint _amount) payable public {\r\n       \r\n            if(_amount > registrationVote[msg.sender] + msg.value) throw;\r\n\r\n            if(opinion == true)\r\n                proposals[proposalIndex].votesInFavour += _amount;\r\n            else proposals[proposalIndex].votesAgainst += _amount;\r\n            \r\n            registrationVote[msg.sender] -= (_amount - msg.value);\r\n            proposals[0].votesInFavour -=  (_amount - msg.value);\r\n            votes[msg.sender] += msg.value;\r\n    }\r\n    \r\n    /*\r\n        invoked at the end of each round\r\n    */\r\n\r\n    function processProposals() external returns (uint newDepositSize) { \r\n        if(msg.sender != proofOfIndividuality) throw;\r\n        \r\n        /* \r\n            Contracts which use functions that use arbitrary-length loops are \r\n            vulnerable to loop-attacks as described on \r\n            http://blog.ethereum.org/2016/06/10/smart-contract-security\r\n            \r\n            To prevent a loop-attack, limit the number of proposals that are processed \r\n            by processProposals() to 1/10th of the current block's max gas limit.\r\n        \r\n        */\r\n        \r\n        uint costSansLoop = 6093;\r\n        uint loopCost = 513;\r\n        uint maxLoops = looper.maximumNumberOfLoops(costSansLoop, loopCost) / 10;\r\n        \r\n        /* Proposals[0] is the default proposal */\r\n        uint iterateToHighest = 0;\r\n        \r\n        uint loopLength;\r\n        if(proposals.length > maxLoops) loopLength = maxLoops;\r\n        else loopLength = proposals.length;\r\n        \r\n        for (uint i = 0; i < loopLength; i++){\r\n            if(\r\n                proposals[i].votesInFavour > proposals[i].votesAgainst \r\n                    && \r\n                proposals[iterateToHighest].votesInFavour < proposals[i].votesInFavour\r\n            )\r\n            iterateToHighest = i;\r\n        }\r\n        \r\n        newDepositSize = proposals[iterateToHighest].depositSize;\r\n        \r\n        roundFinished = true;\r\n        return newDepositSize;\r\n    }\r\n    \r\n    function withdrawDeposit() {\r\n        if(roundFinished == false) throw;\r\n        if(votes[msg.sender] == 0) throw;\r\n        if(!msg.sender.send(votes[msg.sender])) throw;\r\n        votes[msg.sender] = 0;\r\n    }\r\n\r\n}\r\n\r\ncontract DepositGovernanceFactory {\r\n    \r\n    function newDepositGovernance(uint _depositSize, address _poiContract, address _looperContract) returns (address) {\r\n        return new DepositGovernance(_depositSize, _poiContract, _looperContract);\r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_depositSize\",\"type\":\"uint256\"},{\"name\":\"_poiContract\",\"type\":\"address\"},{\"name\":\"_looperContract\",\"type\":\"address\"}],\"name\":\"newDepositGovernance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"}]", "ContractName": "DepositGovernanceFactory", "CompilerVersion": "v0.4.6+commit.2dabbdf0", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}