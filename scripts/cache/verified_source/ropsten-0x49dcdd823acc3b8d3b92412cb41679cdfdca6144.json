{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.8;\r\n/* \r\n    This contract has a minimum lending amount of 0.5 ether. The lent amount can be anything over that.\r\n    A lender can lend less, if it's all that's required to fully fund a loan. The borrower can repay\r\n    any amount. There is some extra logic on the last repayment to make sure that everyone gets \r\n    fully repaid.\r\n*/\r\ncontract LoanContract {\r\n    //Constructor vars\r\n    address borrowerAddress;\r\n    uint public loanAmount;\r\n    uint public fundRaisingDeadline;\r\n    uint public repaymentDeadline;\r\n    \r\n    //Useful vars\r\n    uint public numLenders;\r\n    uint public amountRaised;\r\n    uint public amountRepaid;\r\n    uint public minimumLendAmount = 500000000000000000;\r\n    /* Since solidity doesn't all iterating over mapping, we need 2 data structures to represent lender accounts */\r\n    address[] public lenderAddresses;\r\n    mapping(address => LenderAccount) public lenderAccounts;\r\n    enum State {raising, funded, repaying, repaid, expired} //default?\r\n    State public currentState;\r\n    struct LenderAccount {\r\n        uint amountLent;\r\n        uint amountRepaid;\r\n    }\r\n    \r\n    //Events\r\n    event LentToLoan(address addr, uint amount);\r\n    event DisbursedToBorrower(address addr, uint amount);\r\n    event RepaidByBorrower(address addr, uint amount);\r\n    event RepaidToLender(address addr, uint amount);\r\n    event SentBack(address addr, uint amount);\r\n    event LoanFunded();\r\n    event LoanExpired();\r\n    event LoanRepaid();\r\n    \r\n    // Constructor\r\n    function LoanContract(\r\n        address _borrowerAddress, \r\n        uint loanAmountInEthers,\r\n        uint fundRaisingDurationInDays,\r\n        uint repaymentDurationInDays \r\n    ) {\r\n        borrowerAddress = _borrowerAddress;\r\n        loanAmount = loanAmountInEthers * 1 ether;\r\n        fundRaisingDeadline = now + fundRaisingDurationInDays * 1 days;\r\n        repaymentDeadline = fundRaisingDeadline + repaymentDurationInDays * 1 days;\r\n    }\r\n\r\n    // To keep things simple, the default function handles all logic for both lenders and borrowers\r\n    function() payable {\r\n        if (currentState == State.raising) {\r\n            lend();\r\n        } else if (currentState == State.repaying) {\r\n            repay();\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n    \r\n    // Lender sends wei to the contract, we store how much they lent\r\n    function lend() private {\r\n        // Don't allow borrowers to lend\r\n        if (msg.sender == borrowerAddress) {\r\n            throw;\r\n        }\r\n        // Don't allow overfunding\r\n        if (msg.value > amountLeftToFund()) {\r\n            throw;\r\n        }\r\n        // Don't allow lending less than the minimum, unless it's exactly what's needed to fund the loan\r\n        if (msg.value < minimumLendAmount && msg.value != amountLeftToFund()) {\r\n            throw;\r\n        }\r\n        \r\n        // Handle lender lending twice\r\n        if (lenderAccounts[msg.sender].amountLent == 0) {\r\n            numLenders++;\r\n            lenderAddresses.push(msg.sender);\r\n            lenderAccounts[msg.sender] = LenderAccount(msg.value, 0);\r\n        } else {\r\n            lenderAccounts[msg.sender].amountLent += msg.value;\r\n        }\r\n        \r\n        amountRaised += msg.value;\r\n        LentToLoan(msg.sender, msg.value);\r\n        \r\n        checkLoanFunded();\r\n    }\r\n    \r\n    // Disburse to borrowers account, and move to repaying\r\n    // Note the last lender pays the gas on this but it isn't very expensive)\r\n    function checkLoanFunded() private {\r\n        if (amountRaised >= loanAmount) {\r\n            LoanFunded();\r\n            if (borrowerAddress.send(amountRaised)) {\r\n                currentState = State.repaying;\r\n                DisbursedToBorrower(borrowerAddress, amountRaised);\r\n            } //@todo error case?\r\n        }\r\n    }\r\n    \r\n    // Borrower sends wei to the contract, we disburse to all the lenders\r\n    function repay() private {\r\n        // Only borrowers can repay, and can't repay more than the amount left\r\n        if (msg.sender != borrowerAddress) {\r\n            throw;\r\n        }\r\n        if (msg.value > amountLeftToRepay()) {\r\n            throw;\r\n        }\r\n        \r\n        amountRepaid += msg.value;\r\n        RepaidByBorrower(borrowerAddress, msg.value);\r\n        \r\n        // Distribute wei evenly to lenders, if there's a remainder we'll distribute at the end\r\n        uint amountToDistribute = msg.value;\r\n        uint amountDistributed = 0;\r\n        for (uint i = 0; i < lenderAddresses.length; i++) {\r\n            address currentLender = lenderAddresses[i];\r\n            uint amountForLender = getAmountForLender(amountToDistribute, lenderAccounts[currentLender]);\r\n            if (amountForLender > 0) {\r\n                if (currentLender.send(amountForLender)) {\r\n                    RepaidToLender(currentLender, amountForLender);\r\n                    lenderAccounts[currentLender].amountRepaid += amountForLender;\r\n                    amountDistributed += amountForLender;\r\n                } //@todo error case? Perhaps we need an admin withdrawl bucket for unsendable lender repayments\r\n            }\r\n        }\r\n        \r\n        checkLoanRepaid();\r\n    }\r\n    \r\n    function getAmountForLender(uint amountToDistribute, LenderAccount account) private returns (uint) {\r\n        if (amountRepaid != loanAmount) {\r\n            // Regular case, division in solidity throws away the remainder\r\n            return (amountToDistribute * account.amountLent) / loanAmount;\r\n        } else {\r\n            // Last repayment case, make sure everyone is topped up\r\n            return account.amountLent - account.amountRepaid;\r\n        }\r\n    }\r\n    \r\n    function checkLoanRepaid() private {\r\n        if (amountRepaid == loanAmount) {\r\n            currentState = State.repaid;\r\n            LoanRepaid();\r\n        }\r\n    }\r\n    \r\n    /* Useful constant functions */\r\n    \r\n    function amountLeftToFund() constant returns (uint) {\r\n        return loanAmount - amountRaised;\r\n    }\r\n    \r\n    function amountLeftToRepay() constant returns (uint) {\r\n        return loanAmount - amountRepaid;\r\n    }\r\n    \r\n    function isDelinquent() constant returns (bool) {\r\n        return (now >= repaymentDeadline && currentState != State.repaid);\r\n    }\r\n    \r\n    // Anyone can call this, but it will probably be an admin\r\n    // If the expiration date has passed, send wei back to lenders\r\n    function makeExpired() {\r\n         if (now >= fundRaisingDeadline && currentState != State.expired) {\r\n            currentState = State.expired;\r\n            LoanExpired();\r\n            for (uint i = 0; i < lenderAddresses.length; i++) {\r\n                address currentLender = lenderAddresses[i];\r\n                if (currentLender.send(lenderAccounts[currentLender].amountLent)) {\r\n                    RepaidToLender(currentLender, lenderAccounts[currentLender].amountLent);\r\n                } //@todo error case?\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"repaymentDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountLeftToFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makeExpired\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lenderAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountLeftToRepay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lenderAccounts\",\"outputs\":[{\"name\":\"amountLent\",\"type\":\"uint256\"},{\"name\":\"amountRepaid\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numLenders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRaisingDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumLendAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDelinquent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRepaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_borrowerAddress\",\"type\":\"address\"},{\"name\":\"loanAmountInEthers\",\"type\":\"uint256\"},{\"name\":\"fundRaisingDurationInDays\",\"type\":\"uint256\"},{\"name\":\"repaymentDurationInDays\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LentToLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DisbursedToBorrower\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RepaidByBorrower\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RepaidToLender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SentBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LoanFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LoanExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LoanRepaid\",\"type\":\"event\"}]", "ContractName": "LoanContract", "CompilerVersion": "v0.4.10-nightly.2017.2.3+commit.5ce79609", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007f7af28e85a52934ad15687d42fe9b6ab5d8ebda0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000002d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e5da7473dcfa37352505fc1e135d5e4bc726014ff759ebcee7d096e3e62561ed"}]}