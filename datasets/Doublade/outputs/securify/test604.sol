Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:AccessControlled
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:AccessRoles
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Agreement
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:BasicSnapshotToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:BasicToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Daily
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:DailyAndSnapshotable
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ERC223LegacyCallbackCompat
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:EtherToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:EuroToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:FeeDisbursal
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IAccessControlled
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IAccessPolicy
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IAgreement
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IBasicToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IClonedTokenParent
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IContractId
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC20Allowance
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC20Token
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC223Callback
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC223LegacyCallback
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC223Token
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC677Allowance
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC677Callback
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IERC677Token
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IEthereumForkArbiter
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IFeeDisbursal
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IFeeDisbursalController
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IIdentityRegistry
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IPlatformPortfolio
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ISnapshotable
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ITokenController
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ITokenControllerHook
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ITokenExchangeRateOracle
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ITokenMetadata
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:ITokenSnapshots
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IWithdrawableToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IdentityRecord
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:IsContract
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:KnownContracts
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:KnownInterfaces
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MSnapshotPolicy
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MTokenAllowanceController
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MTokenController
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MTokenMint
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MTokenTransfer
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MTokenTransferController
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Math
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:MintableSnapshotToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Neumark
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:NeumarkIssuanceCurve
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:PlatformTerms
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Reclaimable
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Serialization
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Snapshot
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:StandardRoles
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:StandardSnapshotToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:StandardToken
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:TokenAllowance
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:TokenMetadata
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:TrustlessTokenController
Processing contract: /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol:Universe
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[33mWarning[0m for LockedEther in contract 'AccessRoles':
    |/// @title standard access roles of the Platform
    |/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap
  > |contract AccessRoles {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(381)

[33mWarning[0m for DAOConstantGas in contract 'EtherToken':
    |        address reclaimer = msg.sender;
    |        if(token == RECLAIM_ETHER) {
  > |            reclaimer.transfer(address(this).balance);
    |        } else {
    |            uint256 balance = token.balanceOf(this);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(500)

[33mWarning[0m for DAOConstantGas in contract 'EtherToken':
    |    {
    |        withdrawPrivate(amount);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1228)

[33mWarning[0m for DAOConstantGas in contract 'EtherToken':
    |        }
    |        emit LogWithdrawAndSend(msg.sender, sendTo, amount);
  > |        sendTo.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1248)

[33mWarning[0m for LockedEther in contract 'EtherToken':
    |}
    |
  > |contract EtherToken is
    |    IsContract,
    |    IContractId,
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1143)

[31mViolation[0m for TODAmount in contract 'EtherToken':
    |        address reclaimer = msg.sender;
    |        if(token == RECLAIM_ETHER) {
  > |            reclaimer.transfer(address(this).balance);
    |        } else {
    |            uint256 balance = token.balanceOf(this);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(500)

[33mWarning[0m for TODAmount in contract 'EtherToken':
    |    {
    |        withdrawPrivate(amount);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1228)

[33mWarning[0m for TODAmount in contract 'EtherToken':
    |        }
    |        emit LogWithdrawAndSend(msg.sender, sendTo, amount);
  > |        sendTo.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1248)

[33mWarning[0m for TODReceiver in contract 'EtherToken':
    |        address reclaimer = msg.sender;
    |        if(token == RECLAIM_ETHER) {
  > |            reclaimer.transfer(address(this).balance);
    |        } else {
    |            uint256 balance = token.balanceOf(this);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(500)

[33mWarning[0m for TODReceiver in contract 'EtherToken':
    |    {
    |        withdrawPrivate(amount);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1228)

[33mWarning[0m for TODReceiver in contract 'EtherToken':
    |        }
    |        emit LogWithdrawAndSend(msg.sender, sendTo, amount);
  > |        sendTo.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1248)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |    /// @dev limits function execution only to senders assigned to required 'role'
    |    modifier only(bytes32 role) {
  > |        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));
    |        _;
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(314)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |        // under the new policy. This provides some
    |        // protection against locking yourself out.
  > |        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));
    |
    |        // We can now safely set the new policy without foot shooting.
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(342)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |        address reclaimer = msg.sender;
    |        if(token == RECLAIM_ETHER) {
  > |            reclaimer.transfer(address(this).balance);
    |        } else {
    |            uint256 balance = token.balanceOf(this);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(500)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |            reclaimer.transfer(address(this).balance);
    |        } else {
  > |            uint256 balance = token.balanceOf(this);
    |            require(token.transfer(reclaimer, balance));
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(502)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |        } else {
    |            uint256 balance = token.balanceOf(this);
  > |            require(token.transfer(reclaimer, balance));
    |        }
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(503)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |        require(approve(spender, amount));
    |
  > |        success = IERC677Callback(spender).receiveApproval(
    |            msg.sender,
    |            amount,
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1030)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |    {
    |        withdrawPrivate(amount);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1228)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |        }
    |        emit LogWithdrawAndSend(msg.sender, sendTo, amount);
  > |        sendTo.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1248)

[33mWarning[0m for UnhandledException in contract 'EtherToken':
    |        if (isContract(to)) {
    |            // in case of re-entry (1) transfer is done (2) msg.sender is different
  > |            IERC223Callback(to).tokenFallback(msg.sender, amount, data);
    |        }
    |        return true;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1264)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |    /// @dev limits function execution only to senders assigned to required 'role'
    |    modifier only(bytes32 role) {
  > |        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));
    |        _;
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(314)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |        // under the new policy. This provides some
    |        // protection against locking yourself out.
  > |        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));
    |
    |        // We can now safely set the new policy without foot shooting.
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(342)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |            reclaimer.transfer(address(this).balance);
    |        } else {
  > |            uint256 balance = token.balanceOf(this);
    |            require(token.transfer(reclaimer, balance));
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(502)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |        } else {
    |            uint256 balance = token.balanceOf(this);
  > |            require(token.transfer(reclaimer, balance));
    |        }
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(503)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |        require(approve(spender, amount));
    |
  > |        success = IERC677Callback(spender).receiveApproval(
    |            msg.sender,
    |            amount,
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1030)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |    {
    |        withdrawPrivate(amount);
  > |        msg.sender.transfer(amount);
    |    }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1228)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'EtherToken':
    |        if (isContract(to)) {
    |            // in case of re-entry (1) transfer is done (2) msg.sender is different
  > |            IERC223Callback(to).tokenFallback(msg.sender, amount, data);
    |        }
    |        return true;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1264)

[31mViolation[0m for UnrestrictedWrite in contract 'EtherToken':
    |        // We can now safely set the new policy without foot shooting.
    |        IAccessPolicy oldPolicy = _accessPolicy;
  > |        _accessPolicy = newPolicy;
    |
    |        // Log event
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(346)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |        require(mOnTransfer(from, to, amount));
    |
  > |        _balances[from] = sub(_balances[from], amount);
    |        _balances[to] = add(_balances[to], amount);
    |        emit Transfer(from, to, amount);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(903)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |
    |        _balances[from] = sub(_balances[from], amount);
  > |        _balances[to] = add(_balances[to], amount);
    |        emit Transfer(from, to, amount);
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(904)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |        require((amount == 0 || _allowed[msg.sender][spender] == 0) && mAllowanceOverride(msg.sender, spender) == 0);
    |
  > |        _allowed[msg.sender][spender] = amount;
    |        emit Approval(msg.sender, spender, amount);
    |        return true;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(982)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |            allowed = _allowed[from][msg.sender];
    |            // yes this will underflow but then we'll revert. will cost gas however so don't underflow
  > |            _allowed[from][msg.sender] -= amount;
    |        }
    |        require(allowed >= amount);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1002)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |        private
    |    {
  > |        _balances[msg.sender] = add(_balances[msg.sender], msg.value);
    |        _totalSupply = add(_totalSupply, msg.value);
    |        emit LogDeposit(msg.sender, msg.value);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1300)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |    {
    |        _balances[msg.sender] = add(_balances[msg.sender], msg.value);
  > |        _totalSupply = add(_totalSupply, msg.value);
    |        emit LogDeposit(msg.sender, msg.value);
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1301)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |    {
    |        require(_balances[msg.sender] >= amount);
  > |        _balances[msg.sender] = sub(_balances[msg.sender], amount);
    |        _totalSupply = sub(_totalSupply, amount);
    |        emit LogWithdrawal(msg.sender, amount);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1309)

[33mWarning[0m for UnrestrictedWrite in contract 'EtherToken':
    |        require(_balances[msg.sender] >= amount);
    |        _balances[msg.sender] = sub(_balances[msg.sender], amount);
  > |        _totalSupply = sub(_totalSupply, amount);
    |        emit LogWithdrawal(msg.sender, amount);
    |        emit Transfer(msg.sender, address(0), amount);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1310)

[33mWarning[0m for LockedEther in contract 'FeeDisbursal':
    |
    |/// @title granular fee disbursal contract
  > |contract FeeDisbursal is
    |    IERC223Callback,
    |    IERC677Callback,
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(3938)

[33mWarning[0m for TODAmount in contract 'FeeDisbursal':
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.etherToken());
  > |            EtherToken(token).deposit.value(amount)();
    |        }
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4353)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        }
    |        // count elements with current snapshot id
  > |        uint256 snapshotId = ITokenSnapshots(proRataToken).currentSnapshotId();
    |        uint256 ii = len;
    |        while(_disbursals[token][proRataToken][ii-1].snapshotId == snapshotId && --ii > 0) {}
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4090)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |    {
    |        // only allow verified and active accounts to claim tokens
  > |        require(_feeDisbursalController.onAccept(token, proRataToken, msg.sender), "NF_ACCEPT_REJECTED");
    |        (uint256 claimedAmount, , uint256 nextIndex) = claimPrivate(token, proRataToken, msg.sender, until);
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4120)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        for (i = 0; i < tokens.length; i += 1) {
    |            // only allow verified and active accounts to claim tokens
  > |            require(_feeDisbursalController.onAccept(tokens[i], proRataToken, msg.sender), "NF_ACCEPT_REJECTED");
    |            (claimed[i][0], ,claimed[i][1]) = claimPrivate(tokens[i], proRataToken, msg.sender, UINT256_MAX);
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4143)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |                // do the actual token transfer
    |                IERC223Token ierc223Token = IERC223Token(tokens[i]);
  > |                assert(ierc223Token.transfer(msg.sender, claimed[i][0], ""));
    |            }
    |            // always log, even empty amounts
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4151)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        uint256 fullAmount;
    |        for (i = 0; i < proRataTokens.length; i += 1) {
  > |            require(_feeDisbursalController.onAccept(token, proRataTokens[i], msg.sender), "NF_ACCEPT_REJECTED");
    |            (uint256 amount, , uint256 nextIndex) = claimPrivate(token, proRataTokens[i], msg.sender, UINT256_MAX);
    |            fullAmount += amount;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4168)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            // and now why this method exits - one single transfer of token from many distributions
    |            IERC223Token ierc223Token = IERC223Token(token);
  > |            assert(ierc223Token.transfer(msg.sender, fullAmount, ""));
    |        }
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4177)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |    {
    |        // only allow verified and active accounts to claim tokens
  > |        require(_feeDisbursalController.onReject(token, address(0), msg.sender), "NF_REJECT_REJECTED");
    |        (uint256 claimedAmount, , uint256 nextIndex) = claimPrivate(token, proRataToken, msg.sender, until);
    |        // what was rejected will be recycled
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4189)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        // what was rejected will be recycled
    |        if (claimedAmount > 0) {
  > |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
    |            disburse(token, this, claimedAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4193)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        if (claimedAmount > 0) {
    |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
  > |            disburse(token, this, claimedAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
    |        // log
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4194)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        public
    |    {
  > |        require(_feeDisbursalController.onRecycle(token, proRataToken, investors, until), "");
    |        // cycle through all investors collect the claimable and recycleable funds
    |        // also move the _disbursalProgress pointer
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4268)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        if (totalClaimableAmount > 0) {
    |            // now re-disburse, we're now the disburser
  > |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
    |            disburse(token, this, totalClaimableAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4281)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            // now re-disburse, we're now the disburser
    |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
  > |            disburse(token, this, totalClaimableAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4282)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        public
    |    {
  > |        require(_feeDisbursalController.onChangeFeeDisbursalController(msg.sender, newController), "NF_CHANGING_CONTROLLER_REJECTED");
    |        address oldController = address(_feeDisbursalController);
    |        _feeDisbursalController = newController;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4321)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        IERC20Token token = IERC20Token(tokenAddress);
    |        // this needs a special permission in case of ICBM Euro Token
  > |        require(token.transferFrom(from, address(this), amount));
    |
    |        // now in case we convert from icbm token
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4345)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        if (tokenAddress == ICBM_ETHER_TOKEN) {
    |            // after EtherToken withdraw, deposit ether into new token
  > |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.etherToken());
    |            EtherToken(token).deposit.value(amount)();
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4351)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            // after EtherToken withdraw, deposit ether into new token
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
  > |            token = IERC20Token(UNIVERSE.etherToken());
    |            EtherToken(token).deposit.value(amount)();
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4352)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.etherToken());
  > |            EtherToken(token).deposit.value(amount)();
    |        }
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4353)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            EtherToken(token).deposit.value(amount)();
    |        }
  > |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.euroToken());
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4355)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        }
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
  > |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.euroToken());
    |            // this requires EuroToken DEPOSIT_MANAGER role
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4356)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
  > |            token = IERC20Token(UNIVERSE.euroToken());
    |            // this requires EuroToken DEPOSIT_MANAGER role
    |            EuroToken(token).deposit(this, amount, 0x0);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4357)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            token = IERC20Token(UNIVERSE.euroToken());
    |            // this requires EuroToken DEPOSIT_MANAGER role
  > |            EuroToken(token).deposit(this, amount, 0x0);
    |        }
    |        tokenFallbackPrivate(address(token), from, amount, data);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4359)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |    {
    |        ITokenSnapshots proRataToken;
  > |        PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
    |        uint256 recycleAfterDuration = terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION();
    |        if (data.length == 20) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4396)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        ITokenSnapshots proRataToken;
    |        PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
  > |        uint256 recycleAfterDuration = terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION();
    |        if (data.length == 20) {
    |            proRataToken = ITokenSnapshots(decodeAddress(data));
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4397)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        } else {
    |            // legacy ICBMLockedAccount compat mode which does not send pro rata token address and we assume NEU
  > |            proRataToken = UNIVERSE.neumark();
    |        }
    |        disburse(token, wallet, amount, proRataToken, recycleAfterDuration);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4407)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |    {
    |        require(
  > |            _feeDisbursalController.onDisburse(token, disburser, amount, address(proRataToken), recycleAfterDuration), "NF_DISBURSAL_REJECTED");
    |
    |        uint256 snapshotId = proRataToken.currentSnapshotId();
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4421)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |            _feeDisbursalController.onDisburse(token, disburser, amount, address(proRataToken), recycleAfterDuration), "NF_DISBURSAL_REJECTED");
    |
  > |        uint256 snapshotId = proRataToken.currentSnapshotId();
    |        uint256 proRataTokenTotalSupply = proRataToken.totalSupplyAt(snapshotId);
    |        // if token disburses itself we cannot disburse full total supply
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4423)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |
    |        uint256 snapshotId = proRataToken.currentSnapshotId();
  > |        uint256 proRataTokenTotalSupply = proRataToken.totalSupplyAt(snapshotId);
    |        // if token disburses itself we cannot disburse full total supply
    |        if (token == address(proRataToken)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4424)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        // if token disburses itself we cannot disburse full total supply
    |        if (token == address(proRataToken)) {
  > |            proRataTokenTotalSupply -= proRataToken.balanceOfAt(address(this), snapshotId);
    |        }
    |        require(proRataTokenTotalSupply > 0, "NF_NO_DISBURSE_EMPTY_TOKEN");
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4427)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        nextIndex = min(until, _disbursals[token][proRataToken].length);
    |        uint256 currentIndex = _disbursalProgress[token][proRataToken][claimer];
  > |        uint256 currentSnapshotId = proRataToken.currentSnapshotId();
    |        for (; currentIndex < nextIndex; currentIndex += 1) {
    |            Disbursal storage disbursal = _disbursals[token][proRataToken][currentIndex];
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4495)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        returns (uint256)
    |    {
  > |        uint256 proRataClaimerBalance = proRataToken.balanceOfAt(claimer, snapshotId);
    |        // if no balance then continue
    |        if (proRataClaimerBalance == 0) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4520)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        }
    |        // compute pro rata amount
  > |        uint256 proRataTokenTotalSupply = proRataToken.totalSupplyAt(snapshotId);
    |        // if we disburse token that is pro rata token (downround) then remove what fee disbursal holds from total supply
    |        if (token == address(proRataToken)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4526)

[33mWarning[0m for UnhandledException in contract 'FeeDisbursal':
    |        // if we disburse token that is pro rata token (downround) then remove what fee disbursal holds from total supply
    |        if (token == address(proRataToken)) {
  > |            proRataTokenTotalSupply -= proRataToken.balanceOfAt(address(this), snapshotId);
    |        }
    |        // using round HALF_UP we risks rounding errors to accumulate and overflow balance at the last claimer
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4529)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        }
    |        // count elements with current snapshot id
  > |        uint256 snapshotId = ITokenSnapshots(proRataToken).currentSnapshotId();
    |        uint256 ii = len;
    |        while(_disbursals[token][proRataToken][ii-1].snapshotId == snapshotId && --ii > 0) {}
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4090)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |    {
    |        // only allow verified and active accounts to claim tokens
  > |        require(_feeDisbursalController.onAccept(token, proRataToken, msg.sender), "NF_ACCEPT_REJECTED");
    |        (uint256 claimedAmount, , uint256 nextIndex) = claimPrivate(token, proRataToken, msg.sender, until);
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4120)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        for (i = 0; i < tokens.length; i += 1) {
    |            // only allow verified and active accounts to claim tokens
  > |            require(_feeDisbursalController.onAccept(tokens[i], proRataToken, msg.sender), "NF_ACCEPT_REJECTED");
    |            (claimed[i][0], ,claimed[i][1]) = claimPrivate(tokens[i], proRataToken, msg.sender, UINT256_MAX);
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4143)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |                // do the actual token transfer
    |                IERC223Token ierc223Token = IERC223Token(tokens[i]);
  > |                assert(ierc223Token.transfer(msg.sender, claimed[i][0], ""));
    |            }
    |            // always log, even empty amounts
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4151)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        uint256 fullAmount;
    |        for (i = 0; i < proRataTokens.length; i += 1) {
  > |            require(_feeDisbursalController.onAccept(token, proRataTokens[i], msg.sender), "NF_ACCEPT_REJECTED");
    |            (uint256 amount, , uint256 nextIndex) = claimPrivate(token, proRataTokens[i], msg.sender, UINT256_MAX);
    |            fullAmount += amount;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4168)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            // and now why this method exits - one single transfer of token from many distributions
    |            IERC223Token ierc223Token = IERC223Token(token);
  > |            assert(ierc223Token.transfer(msg.sender, fullAmount, ""));
    |        }
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4177)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |    {
    |        // only allow verified and active accounts to claim tokens
  > |        require(_feeDisbursalController.onReject(token, address(0), msg.sender), "NF_REJECT_REJECTED");
    |        (uint256 claimedAmount, , uint256 nextIndex) = claimPrivate(token, proRataToken, msg.sender, until);
    |        // what was rejected will be recycled
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4189)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        // what was rejected will be recycled
    |        if (claimedAmount > 0) {
  > |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
    |            disburse(token, this, claimedAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4193)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        if (claimedAmount > 0) {
    |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
  > |            disburse(token, this, claimedAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
    |        // log
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4194)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        public
    |    {
  > |        require(_feeDisbursalController.onRecycle(token, proRataToken, investors, until), "");
    |        // cycle through all investors collect the claimable and recycleable funds
    |        // also move the _disbursalProgress pointer
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4268)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        if (totalClaimableAmount > 0) {
    |            // now re-disburse, we're now the disburser
  > |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
    |            disburse(token, this, totalClaimableAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4281)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            // now re-disburse, we're now the disburser
    |            PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
  > |            disburse(token, this, totalClaimableAmount, proRataToken, terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION());
    |        }
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4282)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        public
    |    {
  > |        require(_feeDisbursalController.onChangeFeeDisbursalController(msg.sender, newController), "NF_CHANGING_CONTROLLER_REJECTED");
    |        address oldController = address(_feeDisbursalController);
    |        _feeDisbursalController = newController;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4321)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        IERC20Token token = IERC20Token(tokenAddress);
    |        // this needs a special permission in case of ICBM Euro Token
  > |        require(token.transferFrom(from, address(this), amount));
    |
    |        // now in case we convert from icbm token
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4345)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        if (tokenAddress == ICBM_ETHER_TOKEN) {
    |            // after EtherToken withdraw, deposit ether into new token
  > |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.etherToken());
    |            EtherToken(token).deposit.value(amount)();
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4351)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            // after EtherToken withdraw, deposit ether into new token
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
  > |            token = IERC20Token(UNIVERSE.etherToken());
    |            EtherToken(token).deposit.value(amount)();
    |        }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4352)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            EtherToken(token).deposit.value(amount)();
    |        }
  > |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.euroToken());
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4355)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        }
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
  > |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.euroToken());
    |            // this requires EuroToken DEPOSIT_MANAGER role
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4356)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
  > |            token = IERC20Token(UNIVERSE.euroToken());
    |            // this requires EuroToken DEPOSIT_MANAGER role
    |            EuroToken(token).deposit(this, amount, 0x0);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4357)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            token = IERC20Token(UNIVERSE.euroToken());
    |            // this requires EuroToken DEPOSIT_MANAGER role
  > |            EuroToken(token).deposit(this, amount, 0x0);
    |        }
    |        tokenFallbackPrivate(address(token), from, amount, data);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4359)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |    {
    |        ITokenSnapshots proRataToken;
  > |        PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
    |        uint256 recycleAfterDuration = terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION();
    |        if (data.length == 20) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4396)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        ITokenSnapshots proRataToken;
    |        PlatformTerms terms = PlatformTerms(UNIVERSE.platformTerms());
  > |        uint256 recycleAfterDuration = terms.DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION();
    |        if (data.length == 20) {
    |            proRataToken = ITokenSnapshots(decodeAddress(data));
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4397)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        } else {
    |            // legacy ICBMLockedAccount compat mode which does not send pro rata token address and we assume NEU
  > |            proRataToken = UNIVERSE.neumark();
    |        }
    |        disburse(token, wallet, amount, proRataToken, recycleAfterDuration);
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4407)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |    {
    |        require(
  > |            _feeDisbursalController.onDisburse(token, disburser, amount, address(proRataToken), recycleAfterDuration), "NF_DISBURSAL_REJECTED");
    |
    |        uint256 snapshotId = proRataToken.currentSnapshotId();
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4421)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            _feeDisbursalController.onDisburse(token, disburser, amount, address(proRataToken), recycleAfterDuration), "NF_DISBURSAL_REJECTED");
    |
  > |        uint256 snapshotId = proRataToken.currentSnapshotId();
    |        uint256 proRataTokenTotalSupply = proRataToken.totalSupplyAt(snapshotId);
    |        // if token disburses itself we cannot disburse full total supply
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4423)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |
    |        uint256 snapshotId = proRataToken.currentSnapshotId();
  > |        uint256 proRataTokenTotalSupply = proRataToken.totalSupplyAt(snapshotId);
    |        // if token disburses itself we cannot disburse full total supply
    |        if (token == address(proRataToken)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4424)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        // if token disburses itself we cannot disburse full total supply
    |        if (token == address(proRataToken)) {
  > |            proRataTokenTotalSupply -= proRataToken.balanceOfAt(address(this), snapshotId);
    |        }
    |        require(proRataTokenTotalSupply > 0, "NF_NO_DISBURSE_EMPTY_TOKEN");
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4427)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        nextIndex = min(until, _disbursals[token][proRataToken].length);
    |        uint256 currentIndex = _disbursalProgress[token][proRataToken][claimer];
  > |        uint256 currentSnapshotId = proRataToken.currentSnapshotId();
    |        for (; currentIndex < nextIndex; currentIndex += 1) {
    |            Disbursal storage disbursal = _disbursals[token][proRataToken][currentIndex];
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4495)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        returns (uint256)
    |    {
  > |        uint256 proRataClaimerBalance = proRataToken.balanceOfAt(claimer, snapshotId);
    |        // if no balance then continue
    |        if (proRataClaimerBalance == 0) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4520)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        }
    |        // compute pro rata amount
  > |        uint256 proRataTokenTotalSupply = proRataToken.totalSupplyAt(snapshotId);
    |        // if we disburse token that is pro rata token (downround) then remove what fee disbursal holds from total supply
    |        if (token == address(proRataToken)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4526)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |        // if we disburse token that is pro rata token (downround) then remove what fee disbursal holds from total supply
    |        if (token == address(proRataToken)) {
  > |            proRataTokenTotalSupply -= proRataToken.balanceOfAt(address(this), snapshotId);
    |        }
    |        // using round HALF_UP we risks rounding errors to accumulate and overflow balance at the last claimer
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4529)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'FeeDisbursal':
    |            IWithdrawableToken(tokenAddress).withdraw(amount);
    |            token = IERC20Token(UNIVERSE.etherToken());
  > |            EtherToken(token).deposit.value(amount)();
    |        }
    |        if(tokenAddress == UNIVERSE.getSingleton(KNOWN_INTERFACE_ICBM_EURO_TOKEN)) {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4353)

[31mViolation[0m for UnrestrictedWrite in contract 'FeeDisbursal':
    |        require(_feeDisbursalController.onChangeFeeDisbursalController(msg.sender, newController), "NF_CHANGING_CONTROLLER_REJECTED");
    |        address oldController = address(_feeDisbursalController);
  > |        _feeDisbursalController = newController;
    |        emit LogChangeFeeDisbursalController(oldController, address(newController), msg.sender);
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(4323)

[33mWarning[0m for LockedEther in contract 'IdentityRecord':
    |/// @title describes layout of claims in 256bit records stored for identities
    |/// @dev intended to be derived by contracts requiring access to particular claims
  > |contract IdentityRecord {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2243)

[33mWarning[0m for LockedEther in contract 'IsContract':
    |}
    |
  > |contract IsContract {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(361)

[33mWarning[0m for LockedEther in contract 'KnownContracts':
    |/// should be returned by contractId() method of IContradId.sol. caluclated like so: keccak256("neufund-platform:Neumark")
    |/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap
  > |contract KnownContracts {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(25)

[33mWarning[0m for LockedEther in contract 'KnownInterfaces':
    |///  however for a few contracts we commit platform to particular implementation (all ICBM Contracts, Universe itself etc.)
    |/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap
  > |contract KnownInterfaces {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(41)

[33mWarning[0m for LockedEther in contract 'Math':
    |}
    |
  > |contract Math {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(127)

[33mWarning[0m for LockedEther in contract 'NeumarkIssuanceCurve':
    |}
    |
  > |contract NeumarkIssuanceCurve {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2305)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    /// @param totalEuroUlps actual curve position from which neumarks will be issued
    |    /// @param euroUlps amount against which neumarks will be issued
  > |    function incremental(uint256 totalEuroUlps, uint256 euroUlps)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2334)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    /// @param totalEuroUlps actual curve position from which neumarks will be burned
    |    /// @param burnNeumarkUlps amount of neumarks to burn
  > |    function incrementalInverse(uint256 totalEuroUlps, uint256 burnNeumarkUlps)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2351)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    /// @param minEurUlps euro amount to start inverse search from, inclusive
    |    /// @param maxEurUlps euro amount to end inverse search to, inclusive
  > |    function incrementalInverse(uint256 totalEuroUlps, uint256 burnNeumarkUlps, uint256 minEurUlps, uint256 maxEurUlps)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2370)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    /// @dev binomial expansion does not guarantee monotonicity on uint256 precision for large euroUlps
    |    ///     function below is not monotonic
  > |    function cumulative(uint256 euroUlps)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2387)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    /// @dev in case of many possible inverses, the lowest one will be used (if range permits)
    |    /// @dev corresponds to a linear search that returns first euroUlp value that has cumulative() equal or greater than neumarkUlps
  > |    function cumulativeInverse(uint256 neumarkUlps, uint256 minEurUlps, uint256 maxEurUlps)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2434)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    }
    |
  > |    function neumarkCap()
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2478)

[33mWarning[0m for MissingInputValidation in contract 'NeumarkIssuanceCurve':
    |    }
    |
  > |    function initialRewardFraction()
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2486)

[33mWarning[0m for LockedEther in contract 'PlatformTerms':
    |
    |/// @title set terms of Platform (investor's network) of the ETO
  > |contract PlatformTerms is Math, IContractId {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2019)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // divide v by d, round up if remainder is 0.5 or more
  > |    function divRound(uint256 v, uint256 d)
    |        internal
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(143)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    // mind loss of precision as decimal fractions do not have finite binary expansion
    |    // do not use instead of division
  > |    function decimalFraction(uint256 amount, uint256 frac)
    |        internal
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(155)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    // computes part/total of amount with maximum precision (multiplication first)
    |    // part and total must have the same units
  > |    function proportion(uint256 amount, uint256 part, uint256 total)
    |        internal
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(166)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    //
    |
  > |    function mul(uint256 a, uint256 b)
    |        internal
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(178)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    }
    |
  > |    function add(uint256 a, uint256 b)
    |        internal
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(197)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // fraction of fee deduced on successful ETO (see Math.sol for fraction definition)
  > |    uint256 public constant PLATFORM_FEE_FRACTION = 3 * 10**16;
    |    // fraction of tokens deduced on succesful ETO
    |    uint256 public constant TOKEN_PARTICIPATION_FEE_FRACTION = 2 * 10**16;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2026)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant PLATFORM_FEE_FRACTION = 3 * 10**16;
    |    // fraction of tokens deduced on succesful ETO
  > |    uint256 public constant TOKEN_PARTICIPATION_FEE_FRACTION = 2 * 10**16;
    |    // share of Neumark reward platform operator gets
    |    // actually this is a divisor that splits Neumark reward in two parts
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2028)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    // actually this is a divisor that splits Neumark reward in two parts
    |    // the results of division belongs to platform operator, the remaining reward part belongs to investor
  > |    uint256 public constant PLATFORM_NEUMARK_SHARE = 2; // 50:50 division
    |    // ICBM investors whitelisted by default
    |    bool public constant IS_ICBM_INVESTOR_WHITELISTED = true;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2032)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant PLATFORM_NEUMARK_SHARE = 2; // 50:50 division
    |    // ICBM investors whitelisted by default
  > |    bool public constant IS_ICBM_INVESTOR_WHITELISTED = true;
    |
    |    // minimum ticket size Platform accepts in EUR ULPS
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2034)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // minimum ticket size Platform accepts in EUR ULPS
  > |    uint256 public constant MIN_TICKET_EUR_ULPS = 100 * 10**18;
    |    // maximum ticket size Platform accepts in EUR ULPS
    |    // no max ticket in general prospectus regulation
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2037)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // min duration from setting the date to ETO start
  > |    uint256 public constant DATE_TO_WHITELIST_MIN_DURATION = 7 days;
    |    // token rate expires after
    |    uint256 public constant TOKEN_RATE_EXPIRES_AFTER = 4 hours;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2043)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant DATE_TO_WHITELIST_MIN_DURATION = 7 days;
    |    // token rate expires after
  > |    uint256 public constant TOKEN_RATE_EXPIRES_AFTER = 4 hours;
    |
    |    // duration constraints
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2045)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // duration constraints
  > |    uint256 public constant MIN_WHITELIST_DURATION = 0 days;
    |    uint256 public constant MAX_WHITELIST_DURATION = 30 days;
    |    uint256 public constant MIN_PUBLIC_DURATION = 0 days;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2048)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    // duration constraints
    |    uint256 public constant MIN_WHITELIST_DURATION = 0 days;
  > |    uint256 public constant MAX_WHITELIST_DURATION = 30 days;
    |    uint256 public constant MIN_PUBLIC_DURATION = 0 days;
    |    uint256 public constant MAX_PUBLIC_DURATION = 60 days;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2049)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant MIN_WHITELIST_DURATION = 0 days;
    |    uint256 public constant MAX_WHITELIST_DURATION = 30 days;
  > |    uint256 public constant MIN_PUBLIC_DURATION = 0 days;
    |    uint256 public constant MAX_PUBLIC_DURATION = 60 days;
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2050)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant MAX_WHITELIST_DURATION = 30 days;
    |    uint256 public constant MIN_PUBLIC_DURATION = 0 days;
  > |    uint256 public constant MAX_PUBLIC_DURATION = 60 days;
    |
    |    // minimum length of whole offer
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2051)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // minimum length of whole offer
  > |    uint256 public constant MIN_OFFER_DURATION = 1 days;
    |    // quarter should be enough for everyone
    |    uint256 public constant MAX_OFFER_DURATION = 90 days;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2054)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant MIN_OFFER_DURATION = 1 days;
    |    // quarter should be enough for everyone
  > |    uint256 public constant MAX_OFFER_DURATION = 90 days;
    |
    |    uint256 public constant MIN_SIGNING_DURATION = 14 days;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2056)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant MAX_OFFER_DURATION = 90 days;
    |
  > |    uint256 public constant MIN_SIGNING_DURATION = 14 days;
    |    uint256 public constant MAX_SIGNING_DURATION = 60 days;
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2058)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    uint256 public constant MIN_SIGNING_DURATION = 14 days;
  > |    uint256 public constant MAX_SIGNING_DURATION = 60 days;
    |
    |    uint256 public constant MIN_CLAIM_DURATION = 7 days;
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2059)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    uint256 public constant MAX_SIGNING_DURATION = 60 days;
    |
  > |    uint256 public constant MIN_CLAIM_DURATION = 7 days;
    |    uint256 public constant MAX_CLAIM_DURATION = 30 days;
    |
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2061)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    uint256 public constant MIN_CLAIM_DURATION = 7 days;
  > |    uint256 public constant MAX_CLAIM_DURATION = 30 days;
    |
    |    // time after which claimable tokens become recycleable in fee disbursal pool
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2062)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // time after which claimable tokens become recycleable in fee disbursal pool
  > |    uint256 public constant DEFAULT_DISBURSAL_RECYCLE_AFTER_DURATION = 4 * 365 days;
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2065)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |
    |    // calculates investor's and platform operator's neumarks from total reward
  > |    function calculateNeumarkDistribution(uint256 rewardNmk)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2072)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    }
    |
  > |    function calculatePlatformTokenFee(uint256 tokenAmount)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2083)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    }
    |
  > |    function calculatePlatformFee(uint256 amount)
    |        public
    |        pure
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2092)

[33mWarning[0m for MissingInputValidation in contract 'PlatformTerms':
    |    //
    |
  > |    function contractId() public pure returns (bytes32 id, uint256 version) {
    |        return (0x95482babc4e32de6c4dc3910ee7ae62c8e427efde6bc4e9ce0d6d93e24c39323, 1);
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2104)

[33mWarning[0m for LockedEther in contract 'Serialization':
    |
    |/// @title serialization of basic types from/to bytes
  > |contract Serialization {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(2110)

[33mWarning[0m for LockedEther in contract 'StandardRoles':
    |}
    |
  > |contract StandardRoles {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(283)

[33mWarning[0m for LockedEther in contract 'TokenMetadata':
    |/// @title adds token metadata to token contract
    |/// @dev see Neumark for example implementation
  > |contract TokenMetadata is ITokenMetadata {
    |
    |    ////////////////////////
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(532)

[33mWarning[0m for MissingInputValidation in contract 'TokenMetadata':
    |    ////////////////////////
    |
  > |    function name()
    |        public
    |        constant
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(577)

[33mWarning[0m for MissingInputValidation in contract 'TokenMetadata':
    |    }
    |
  > |    function symbol()
    |        public
    |        constant
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(585)

[33mWarning[0m for MissingInputValidation in contract 'TokenMetadata':
    |    }
    |
  > |    function decimals()
    |        public
    |        constant
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(593)

[33mWarning[0m for MissingInputValidation in contract 'TokenMetadata':
    |    }
    |
  > |    function version()
    |        public
    |        constant
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(601)

[31mViolation[0m for LockedEther in contract 'Universe':
    |/// collections of known instances of interfaces
    |/// @dev interfaces are identified by bytes4, see KnownInterfaces.sol
  > |contract Universe is
    |    Agreement,
    |    IContractId,
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(3603)

[33mWarning[0m for UnhandledException in contract 'Universe':
    |    /// @dev limits function execution only to senders assigned to required 'role'
    |    modifier only(bytes32 role) {
  > |        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));
    |        _;
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(314)

[33mWarning[0m for UnhandledException in contract 'Universe':
    |        // under the new policy. This provides some
    |        // protection against locking yourself out.
  > |        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));
    |
    |        // We can now safely set the new policy without foot shooting.
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(342)

[33mWarning[0m for UnhandledException in contract 'Universe':
    |        returns (bool)
    |    {
  > |        return accessPolicy().allowed(legalRepresentative, ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, this, msg.sig);
    |    }
    |}
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1618)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Universe':
    |    /// @dev limits function execution only to senders assigned to required 'role'
    |    modifier only(bytes32 role) {
  > |        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));
    |        _;
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(314)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Universe':
    |        // under the new policy. This provides some
    |        // protection against locking yourself out.
  > |        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));
    |
    |        // We can now safely set the new policy without foot shooting.
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(342)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'Universe':
    |        returns (bool)
    |    {
  > |        return accessPolicy().allowed(legalRepresentative, ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, this, msg.sig);
    |    }
    |}
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1618)

[31mViolation[0m for UnrestrictedWrite in contract 'Universe':
    |pragma solidity 0.4.25;
    |
  > |/// @title makes modern ERC223 contracts compatible with the legacy implementation
    |/// @dev should be used for all receivers of tokens sent by ICBMEtherToken and NEU
    |contract ERC223LegacyCallbackCompat {
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'Universe':
    |        // We can now safely set the new policy without foot shooting.
    |        IAccessPolicy oldPolicy = _accessPolicy;
  > |        _accessPolicy = newPolicy;
    |
    |        // Log event
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(346)

[31mViolation[0m for UnrestrictedWrite in contract 'Universe':
    |            agreementUri: agreementUri
    |        });
  > |        _amendments.push(amendment);
    |        emit LogAgreementAmended(msg.sender, agreementUri);
    |    }
  at /home/jiaming/mavs_srcs/contract@0x26b7dedab33c58bc9edc26d9cd81b8eee43c24dd.sol(1524)


